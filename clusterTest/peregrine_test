#!/bin/bash

################################################################################
#    GLOBALS & ARGUMENT PARSING                                                #
################################################################################

call_count=1         # test counter
fail_count=0         # failed test counter
colour_flag='false'  # colour the words 'PASSED/FAILED' in test output

LEADING_TAB='    '
HELP_STR="usage: peregrine_test [-c, --colour]\n${LEADING_TAB}c: colour PASSED/FAILED output" 

# check if verbose help option is given anywhere
if [[ $@ =~ "--help" ]]
then
    echo -e "$HELP_STR"
    exit
fi

# check for the verbose 'colo(u)r' flag
if [ "$1" = "--colour" ] || [ "$1" = "--color" ]
then
    colour_flag='true'
else
    # check for the 'c' (colouring) and 'h' (help) flags
    while getopts 'ch' COLOUR
        do
            case $COLOUR in
                c) colour_flag='true';;
                h) echo -e "$HELP_STR"; exit;;
                *) printf 'peregrine_test got an unsupported option.  Quitting...\n\n'; exit 126;;
            esac
        done
fi


################################################################################
#    PRINTING HELPER METHODS                                                   #
################################################################################

function print_line()
{
    local OPTIND OPTION OPTARG num_char

    num_char=$(tput cols)

    while getopts 'n:' OPTION
    do
        case $OPTION in
            n)  num_char="${OPTARG}";;
            *)  printf 'print_line got unsupported option: %s' "${OPTION}";;
        esac
    done

    shift $(( OPTIND - 1 ))

    for ((i=1; i<=$num_char; i++))
    do
        echo -n $1
    done
    echo
}


function print_message(){

    echo -e "\n${LEADING_TAB}TEST #$call_count    "
    print_line '-'
    
    if [[ $1 = 0 ]]
    then
        # colour the output of failed tests
        if [[ $colour_flag = 'true' ]]
        then
            echo -e "\033[0;42m PASSED:\033[0m $2"
        else
            echo -e " PASSED: $2"
        fi
    else
        # colour the output of failed tests
        if [[ $colour_flag = 'true' ]]
        then
            echo -e "\033[0;41m FAILED:\033[0m $2"
        else
            echo -e " FAILED: $2"
        fi

        ((fail_count++))
    fi

    echo
    print_line "="
    echo

    ((call_count++))

}


function print_results(){
    # finished testing
    print_line '+'
    printf '\n RESULT: Peregrine test is finished. %s tests failed.\n\n' "${fail_count}"
}



################################################################################
#    MODULE MANAGEMENT TESTS                                                   #
################################################################################

function get_loaded_modules(){
    # get a list of modules which are loaded in the current session

    loaded_modules=`(module -t list 2>&1)`  # -t option forces output to 1 column
    echo $loaded_modules
}

function grep_loaded_modules(){

    local OPTIND OPTION

    loaded_modules=$(get_loaded_modules)

    while getopts "c" OPTION
    do
        case $OPTION in
            c)
                shift $(( OPTIND - 1 ))  # remove the -c option
                module_array=$@
                #      list modules      output newline   regex  (replace space with |)   count
                echo "$loaded_modules" | sed "s/ /\n/g" | grep -E ${module_array//\ /|} | wc -l
                return 0
                ;;
            *)
                printf 'grep_loaded_modules got unknown option %s' "${OPTION}";;
        esac
    done

    echo "$loaded_modules" | sed "s/ /\n/g" | grep $1
}


echo
print_line '#'
echo -e "\n        PEREGRINE TESTING\n"
print_line '#'
echo


#    TEST: LOADING MODULES
########################################

echo -e "Starting loading module test\n"

# get the first three modules to load
modules_str=( $(ls /software/modules/all -1 | head -3) )
modules_array=${modules_str[@]}

# load the first three modules
module load $modules_array

# check that all modules are loaded
returned_num_modules_loaded="$(grep_loaded_modules -c $modules_array)"
expected_num_modules_loaded=3

test $returned_num_modules_loaded -eq $expected_num_modules_loaded && print_message 0 "All modules loaded" || print_message 1 "All modules not loaded"


#    TEST: DELETING MODULES
########################################

echo -e "Starting deleting module test\n"

# delete the first module
module_str=${modules_str[0]}

module del $module_str

# check that the module has been removed
is_deleted=$(grep_loaded_modules "$module_str")

test -z $is_deleted && print_message 0 "Module deleted successfully" || print_message 1 "Module failed to delete"


#    TEST: SAVING & PURGING MODULES
#######################################

echo -e "Starting purging module test\n"

# save the other two modules as the default list
module save &> /dev/null  # don't print output

# purge all modules
module purge

# check that all modules have been removed
loaded_modules=$(get_loaded_modules)
if [[ "$loaded_modules" = "No modules loaded" ]]
then
    print_message 0 "All modules purged"
else
    print_message 1 "All modules not purged"
fi


#    TEST: RESTORING MODULES
#########################################

echo -e "Starting restoring module test\n"

# restore from default list
module restore &> /dev/null

# check that the modules have been restored
returned_num_modules_loaded=$(grep_loaded_modules -c $modules_array)
expected_num_modules_loaded=2
test $returned_num_modules_loaded -eq $expected_num_modules_loaded && print_message 0 "All modules restored" || print_message 1 "All modules not restored"



################################################################################
#    I/O TESTS                                                                 #
################################################################################

#    TEST: CHECK WRITE ACCESS TO /home AND /data 
########################################

# check if the /home dir is mounted correctly
echo -e "Checking for write access to /home\n"

<<<<<<< Updated upstream
if touch /home/$USER/peregrine_test_file.txt
=======
test_output=`(touch /home/peregrine_test_file.txt 2>&1)`

if [ -z "$test_output" ]
>>>>>>> Stashed changes
then
    print_message 0 "/home is mounted and writable. Removing test file..."
    rm /home/$USER/peregrine_test_file.txt
else
    print_message 1 "/home is not writable"
fi


# check if the /home dir is mounted correctly
echo -e "Checking for write access to /data\n"

<<<<<<< Updated upstream
if touch /data/$USER/peregrine_test_file.txt
=======
test_output=`(touch /data/peregrine_test_file.txt 2>&1)`

if [ -z "$test_output" ]
>>>>>>> Stashed changes
then
    print_message 0 "/data is mounted and writable. Removing test file..."
    rm /data/$USER/peregrine_test_file.txt
else
    print_message 1 "/data is not writable"
fi



################################################################################
#    JOB MANAGEMENT & OPENMP TESTS                                             #
################################################################################

#    TEST: SUBMIT A JOB
########################################

# ensure that the test file exists
if [ ! -x ./peregrine_test_job.sh ];
then
    echo "peregrine_test_job.sh not found or is not executable"
    echo -e "\nperegrine_test cannot continue...\n"
    
    print_results

    exit 126
fi

# check that we can compile the test omp file
echo -e "Compiling test omp file\n"

# compile the test 'omp' C++ file. The resulting binary file is run in peregrine_test_job.sh script.
compilation_output=`(g++ -o peregrine_test_omp -fopenmp peregrine_test_omp.cc 2>&1)`

if [ -z "$compilation_output" ]
then
    print_message 0 "Test omp file compiled successfully"
else
    print_message 1 "Test omp file did not compile successfully\n\nCOMPILATION OUTPUT:\n\n$compilation_output"
fi

echo -e "Running test job\n"

sbatch_output="$(sbatch peregrine_test_job.sh)"
sleep 5  # sleep to allow to out-file to be written to
job_id="$(echo $sbatch_output | grep -oE '[^ ]+$')"  # 'grep' gets the last word (the job id)

scontrol_output="$(scontrol show jobid -dd $job_id)"

# check that the job is submitted
test -n "$(echo $scontrol_output | grep -E 'PENDING|RUNNING|COMPLETED')" && print_message 0 "Test job successfully submitted" || print_message 1 "Test job failed to submit"


#    TEST: CANCEL A JOB
########################################

echo -e "Cancelling test job"

# cancel the job
scancel $job_id
sleep 5  # sleep to allow the out-file to be written to
scontrol_output="$(scontrol show jobid -dd $job_id)"

# copy the contents of the output file
slurm_file="slurm-$job_id.out"
SLURM_OUTPUT=$(<${slurm_file})

# check that the job is cancelled
test -n "$(echo $scontrol_output | grep 'CANCELLED')" && print_message 0 "Test job successfully cancelled" || print_message 1 "Test job failed to cancel"

echo "SLURM OUTPUT FILE CONTENTS FOR JOB $job_id"
echo
echo "${SLURM_OUTPUT}"
echo

# delete the output file when we're done
rm $slurm_file

print_results
